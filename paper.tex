\documentclass[11pt, letterpaper, oneside, twocolumn] {article}
\usepackage{verbatim, minted}

\begin{document}

\title{HaPy \\
Haskell for Python
}
\author{David Fisher, Ashwin Siripurapu, and William Rowan}
\maketitle

\section{Introduction}

\section{Motivation}
It is a truth universally acknowledged, that a single Python module in possession of a good GUI, must be in want of a Haskell backend. Joking aside, three trends are clear when looking at the most recent State of Haskell survey and other data: in the first place, Haskellers primarily use Haskell for mathematical analysis, parsing/compiling, and (increasingly) web development; importantly, GUI development in Haskell is almost non-existent. Secondly, Python remains a popular language for creating GUIs, because of its high-level, human-readable syntax and intuitive ease of use. Lastly, Python code is much slower than the corresponding C code, while Haskell's performance is generally almost as good as C's for most use cases. This is in spite of the fact that Python and Haskell are both very high-level languages. 

\section{Use}
Importing a Haskell module into a Python program is easy with HaPy: simply add the line
\begin{minted}{python}
from HaPy import HsModule
\end{minted}
to the head of any Python script. This will dynamically load the specified Haskell module, so that any Haskell function defined in HsModule can be accessed and executed by the Python script. \\
Installing HaPy is similarly intuitive, but with the caveat that all libraries called by HaPy.hs must be dynamically-linkable. This means that all of the packages that HaPy.hs imports must be reinstalled with Cabal, using the \verb!--enable-shared! flag. \footnote{The requirement that these packages be dynamically-linkable is enforced by Python's ctypes module, which we use to marshall primitive types across the Haskell-Python interface.} \\
However, Haskell packages that are used by the user's Haskell code need not be dynamically-linkable. Indeed, on the Haskell side, no special support is needed by the user; literally any standard Haskell code will run with HaPy. All the issues of marshalling data and passing data to and from the Foreign Function Interface are managed by the code in HaPy.hs \\
This has the added benefit of enabling the user to call any code defined in the Haskell standard libraries from Python. 
\subsection{Loading Haskell Modules}

\subsection{Haskell types in Python}

\section{Implementation}

\subsection{Dynamic Loading of Haskell modules}

\subsection{Function Currying}

\subsection{Type checking}

\section{Future work}
In future, HaPy could support dynamic conversion from GADTs to Python types when instance of user-defined Haskell data are passed from the Haskell layer to the Python layer---in particular, Haskell's product types would map to Python classes while Haskell's sum types could be represented in Python by an enumerated type. 

\section{Refernces}
System.Plugins stuff.

\end{document}
