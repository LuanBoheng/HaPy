\documentclass[11pt, letterpaper, oneside, twocolumn] {article}
\usepackage{verbatim, minted}

\begin{document}

\title{HaPy \\
Haskell for Python
}
\author{David Fisher, Ashwin Siripurapu, and William Rowan}
\maketitle

\section{Introduction}
% - what is HaPy?
% - focuses on ease of use
%  - to acomplish this: should be pythonic
%  - completely transparent!
%  - no coding overhead on either side (shouldn't be aware that you're using haskell on python side, don't need to code for python in haskell -> should be able to use any haskell module on system)

\section{Motivation}
It is a truth universally acknowledged, that a single Python module in possession of a good GUI, must be in want of a Haskell backend. Joking aside, three trends are clear when looking at the most recent State of Haskell survey and other data: in the first place, Haskellers primarily use Haskell for mathematical analysis, parsing/compiling, and (increasingly) web development; importantly, GUI development in Haskell is almost non-existent. Secondly, Python remains a popular language for creating GUIs, because of its high-level, human-readable syntax and intuitive ease of use. Lastly, Python code is much slower than the corresponding C code, while Haskell's performance is generally almost as good as C's for most use cases. This is in spite of the fact that Python and Haskell are both very high-level languages. 
% - general motivation: haskell and python are good at different things
%  - in a large project: good to be able to do each piece in the best language
%  - usefullness is inversely proportional to friction (so now maximally useful)
% - example use case:
%  - python GUI, haskell backend
%  - (or existing python project)
%  - (or existing haskell library)

\section{Use}
Our goal with HaPy is to allow the user to call arbitrary Haskell code while remaining committed to ``Pythonic'' syntax. In particular, importing a Haskell module into a Python program is easy with HaPy: simply add the line
\begin{minted}{python}
from HaPy import HsModule
\end{minted}
or
\beign{minted}{python}
import HaPy.HsModule
\end{minted}
to the head of any Python script. This will dynamically load the specified Haskell module, so that any Haskell function defined in HsModule can be accessed and executed by the Python script, as though it were code defined in another Python module. For instance, if HsModule defines a function \verb!sum! which takes two real numbers and returns their sum, the result can be printed in Python with
\begin{minted}{python}
print HsModule.sum(first, second)
\end{minted}
Installing HaPy is similarly intuitive, but with the caveat that all libraries called by HaPy.hs must be dynamically-linkable. This means that all of the packages that HaPy.hs imports must be reinstalled with Cabal, using the \verb!--enable-shared! flag. \footnote{The requirement that these packages be dynamically-linkable is enforced by Python's ctypes module, which we use to marshall primitive types across the Haskell-Python interface.} \\
However, Haskell packages that are used by the user's Haskell code need not be dynamically-linkable. Indeed, on the Haskell side, no special support is needed by the user; literally any standard Haskell code will run with HaPy. All the issues of marshalling data and passing data to and from the Foreign Function Interface are managed by the code in HaPy.hs \\
This has the added benefit of enabling the user to call any code defined in the Haskell standard libraries from Python. 
% - Meshing python and haskell semantics

\subsection{Loading Haskell Modules}
As noted previously, the syntax for loading Haskell modules is identical to the normal Python import syntax. All Haskell modules are represented as submodules of the HaPy module, in order that the Python interpreter should not mistake them for Python modules. \\
Furthermore, the Haskell module hierarchy is preserved, so for instance one can say
\begin{minted}{python}
import HaPy.Data.List
\end{minted}
% - super easy: all haskell modules represented as submodules of HaPy
%  - standard haskell module represnetnation (e.x. System.Plugins) preserved
% - import HaPy.Data.List

\subsection{Haskell types in Python}
% - some automarshalled (haskell functions, haskell primitive types)
% - others opaque
% - support function currying
%  - haskell functions in python have haskell-type access if desired
%  - can be ignored
%  - can apply a few arguments at once
% -  returns a new function every time
% - can apply opaque haskell types
% - automatically marshall (if possible) once all args applied

\section{Implementation}

% - Split across three languages
%  - to our surprise currently very little in C
%  - choice of what language to work in for each feature
% - Python side uses Ctypes to dynamically load our precompiled C and Haskell shared object file 
%  - idea: in future statily compile C-python module

\subsection{Dynamic Loading of Haskell modules}

% - hs-plugins

\subsection{Function Currying}

% C interface supports applying one argument at a time for each of 

\subsection{Type checking}

% David

\section{Future work}

\subsection{Type checking}

% real type checking

\subsection{Supporting more types}
In addition to marshalling primitive types across the Haskell-Python interface, we would eventually like to be able to marshall Python lists into Haskell lists and vice versa. One potential challenge here would be the marshalling of infinitely long, lazily-evaluated lists from Haskell to Python. \\
A bigger challenge would be dynamically converting from algebraic data types (ADTs) defined in Haskell to Python objects; for example, a simple product type composed of Haskell primitives could be represented as a named tuple\footnote{Effectively a fixed-size dictionary} in Python.
% marshalling lists
% mashralling ADTs

\subsection{Improved dynamic loading}

% 64-bit bug
% difficultly in loading preinstalled modules
%  - plugins only supports very simply model (like assuming that .hi file is next to .o file)
% requires dynamic libraries

\subsection{Simplied install}

% require user of compiled binary to have dynamically compiled binary of haskell libraries

\subsection{Passing Python Callbacks}
Lastly, we would like to allow users to pass Python functions to Haskell; an example use case might be passing a comparison function for Haskell to use in sorting a list. Python's ctypes module already supports passing Python functions to C code (provided that the functions take only arguments which can be converted to C types), so presumably we would use this to facilitate the passing of Python function pointers to Haskell. Once we have a pointer to a Python function in C, Haskell data can be marshalled into an appropriate ctype for the function to act on, and the return type of the function can subsequently be converted back into a Haskell type.
\section{Refernces}

% hs-plugins 
% missing py?

\end{document}
