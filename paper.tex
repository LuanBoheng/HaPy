\documentclass[11pt, letterpaper, oneside, twocolumn] {article}
\usepackage{verbatim, minted}

\begin{document}

\title{HaPy \\
Haskell for Python
}
\author{David Fisher, Ashwin Siripurapu, and William Rowan}
\maketitle

\section{Introduction}
% - what is HaPy?
% - focuses on ease of use
%  - to acomplish this: should be pythonic
%  - completely transparent!
%  - no coding overhead on either side (shouldn't be aware that you're using haskell on python side, don't need to code for python in haskell -> should be able to use any haskell module on system)

\section{Motivation}
It is a truth universally acknowledged, that a single Python module in possession of a good GUI, must be in want of a Haskell backend. Joking aside, three trends are clear when looking at the most recent State of Haskell survey and other data: in the first place, Haskellers primarily use Haskell for mathematical analysis, parsing/compiling, and (increasingly) web development; importantly, GUI development in Haskell is almost non-existent. Secondly, Python remains a popular language for creating GUIs, because of its high-level, human-readable syntax and intuitive ease of use. Lastly, Python code is much slower than the corresponding C code, while Haskell's performance is generally almost as good as C's for most use cases. This is in spite of the fact that Python and Haskell are both very high-level languages. 
% - general motivation: haskell and python are good at different things
%  - in a large project: good to be able to do each piece in the best language
%  - usefullness is inversely proportional to friction (so now maximally useful)
% - example use case:
%  - python GUI, haskell backend
%  - (or existing python project)
%  - (or existing haskell library)

\section{Use}
Our goal with HaPy is to allow the user to call arbitrary Haskell code while remaining committed to ``Pythonic'' syntax. In particular, importing a Haskell module into a Python program is easy with HaPy: simply add the line
\begin{minted}{python}
from HaPy import HsModule
\end{minted}
or
\beign{minted}{python}
import HaPy.HsModule
\end{minted}
to the head of any Python script. This will dynamically load the specified Haskell module, so that any Haskell function defined in HsModule can be accessed and executed by the Python script, as though it were code defined in another Python module. For instance, if HsModule defines a function \verb!sum! which takes two real numbers and returns their sum, the result can be printed in Python with
\begin{minted}{python}
print HsModule.sum(first, second)
\end{minted}
Installing HaPy is similarly intuitive, but with the caveat that all libraries called by HaPy.hs must be dynamically-linkable. This means that all of the packages that HaPy.hs imports must be reinstalled with Cabal, using the \verb!--enable-shared! flag. \footnote{The requirement that these packages be dynamically-linkable is enforced by Python's ctypes module, which we use to marshall primitive types across the Haskell-Python interface.} \\
However, Haskell packages that are used by the user's Haskell code need not be dynamically-linkable. Indeed, on the Haskell side, no special support is needed by the user; literally any standard Haskell code will run with HaPy. All the issues of marshalling data and passing data to and from the Foreign Function Interface are managed by the code in HaPy.hs \\
This has the added benefit of enabling the user to call any code defined in the Haskell standard libraries from Python. 
% - Meshing python and haskell semantics

\subsection{Loading Haskell Modules}
As noted previously, the syntax for loading Haskell modules is identical to the normal Python import syntax. All Haskell modules are represented as submodules of the HaPy module, in order that the Python interpreter should not mistake them for Python modules. \\
Furthermore, the Haskell module hierarchy is preserved, so for instance one can say
\begin{minted}{python}
import HaPy.Data.List
\end{minted}
% - super easy: all haskell modules represented as submodules of HaPy
%  - standard haskell module represnetnation (e.x. System.Plugins) preserved
% - import HaPy.Data.List

\subsection{Haskell types in Python}
% - some automarshalled (haskell functions, haskell primitive types)
% - others opaque
% - support function currying
%  - haskell functions in python have haskell-type access if desired
%  - can be ignored
%  - can apply a few arguments at once
% -  returns a new function every time
% - can apply opaque haskell types
% - automatically marshall (if possible) once all args applied

\section{Implementation}

% - Split across three languages
%  - to our surprise currently very little in C
%  - choice of what language to work in for each feature
% - Python side uses Ctypes to dynamically load our precompiled C and Haskell shared object file 
%  - idea: in future statily compile C-python module

\subsection{Dynamic Loading of Haskell modules}

HaPy uses the HSPlugins package to dynamically load requested Haskell modules. HSPlugins supports more than just dynamic loading of external object files. Most of the meat of the package is in two crucial components: the loading of dependent modules and dynamic type checking.

HaPy doesn't actually use the dynamic type checking features of HSPlugins. This feature requires that client Haskell supply static types to check against. This make sense for HSPlugins intended use case, the loading of plugins that implement known interfaces. We, however, need to be able to load any Haskell module with any interface at runtime. We therefore ask HSPlugins to load all symbols as an opaque data type (literally \emph{data Opaque}) which will loose its type information when passed back to the Python side anyway.

HSPlugins supports a simple, but limited interface for loading modules. The client is expected to pass a string representing the path to the object file containing the requested module and a string representing the symbol to be loaded. An implicit expectation is that the Haskell interface file for the requested module sits next to the object file on the file system and has the same base name.

While this condition holds for locally compiled modules (GHC by default generates the object file and interface file next to each other) this doesn't hold for Haskell packages installed on the system. Loading modules from these packages posed several challenges. The first is finding the location of a package's object file from the module name. The module \emph{System.Plugins}, for example, might be provided by the package \emph{plugins-1.5.1.4}. Fortunately, we are able to use the GHC api to do this lookup for us which we then translate into a path to the object file.

Our method of doing so is not robust, however. Ideally, we would be able to ask GHC to invoke the same mechanism that it uses to lookup modules when the user requests packages in GHCi but the complexity and opacity of the GHC api made it impossible to do this in our timeframe.

The second challenge involved satisfying HSPlugins assumption that the Haskell interface file sits next to the object file for the module. Packages might provide many different modules, the interface files for which are stored underneath the the package's base directory in a file structure mimicing the package structure. We had to thus copy the requested interface file to the location expected by HSPlugins.

Again, this mechanism is not robust. It will be important to utilize GHC's import mechanism in the future. Properly importing both local and package modules will probably require either utilizing HSPlugins' low level api or abandoing it altogether.

\subsection{Function Currying}

% C interface supports applying one argument at a time for each of 

\subsection{Type checking}

% David

\section{Future work}

\subsection{Type checking}

% real type checking

\subsection{Supporting more types}
In addition to marshalling primitive types across the Haskell-Python interface, we would eventually like to be able to marshall Python lists into Haskell lists and vice versa. One potential challenge here would be the marshalling of infinitely long, lazily-evaluated lists from Haskell to Python. \\
A bigger challenge would be dynamically converting from algebraic data types (ADTs) defined in Haskell to Python objects; for example, a simple product type composed of Haskell primitives could be represented as a named tuple\footnote{Effectively a fixed-size dictionary} in Python.
% marshalling lists
% mashralling ADTs

\subsection{Improved dynamic loading}

% 64-bit bug
% difficultly in loading preinstalled modules
%  - plugins only supports very simply model (like assuming that .hi file is next to .o file)
% requires dynamic libraries

\subsection{Simplied install}

% require user of compiled binary to have dynamically compiled binary of haskell libraries

\subsection{Passing Python Callbacks}
Lastly, we would like to allow users to pass Python functions to Haskell; an example use case might be passing a comparison function for Haskell to use in sorting a list. Python's ctypes module already supports passing Python functions to C code (provided that the functions take only arguments which can be converted to C types), so presumably we would use this to facilitate the passing of Python function pointers to Haskell. Once we have a pointer to a Python function in C, Haskell data can be marshalled into an appropriate ctype for the function to act on, and the return type of the function can subsequently be converted back into a Haskell type.
\section{Refernces}

% hs-plugins 
% missing py?

\end{document}
